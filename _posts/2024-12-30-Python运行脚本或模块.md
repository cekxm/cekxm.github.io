---
layout: post
title: "Python运行脚本或模块"
date: 2024-12-30 00:26:04 +0800
categories: []
description: 简要介绍
tags: 
thumbnail: 
toc:
  sidebar: left
typora-root-url: ../
---


以下面文件 hello.py 为例

```python
print('Hello World!')

def funx():
    print('In funx!')

if __name__ == '__main__':
    print('In hello main')
```



## import hello

```python
>>> import hello
Hello World!
>>> import hello
>>> 
```

1. 该语句以名字 hello 引入模块，所以 `__main__` 不会执行。
2. 多次 import，执行一次

## python script.py

```bash
PS D:\projects\test> python hello.py
Hello World!
In hello main
PS D:\projects\test> python hello.py
Hello World!
In hello main
PS D:\projects\test>
```

1. 该语句以名字 `__main__` 运行脚本
2. 你必须提供脚本的地址，否则找不到

## python -m hello

```
PS D:\projects\test> python -m hello
Hello World!
In hello main
PS D:\projects\test> python -m hello
Hello World!
In hello main
PS D:\projects\test>
```

1. 该语句以名字 `__main__` 运行模块，会运行 `__main__` 的语句
2. python 会自动在 `sys.path` 系统路径中寻找模块，并引入
3. `-m` 后面要接模块名字，而不能是 `str`，也就是说不能接 py 文件

## runpy.run_module(mod_name="hello")

```python
>>> runpy.run_module(mod_name="hello")   
Hello World!
{'__name__': 'hello', '__file__': 'D:\\projects\\test\\hello.py',
...}
>>> hello_dic = runpy.run_module(mod_name="hello") 
Hello World!
>>> hello_dic['funx']()
In funx!
>>>
```

1. 该语句以名字 hello 运行模块，所以 `__main__` 不会执行。
2. 返回一个词典，可以访问这个词典
3. 多次 run_module，会执行多次，这和 import 是不一样的。
4. 和 `-m` 一样，会在系统路径中寻找 module

## runpy.run_path(path_name="hello.py")

```python
>>> runpy.run_path(path_name="hello.py")
Hello World!
{'__name__': '<run_path>', '__doc__': None,...}
>>> hello_dic = runpy.run_path(path_name="hello.py") 
Hello World!
>>> hello_dic['funx']()
In funx!
>>>
```

1. 该语句以名字 `<run_path>`  运行模块，所以 `__main__` 不会执行。
2. 返回一个词典，可以访问这个词典
3. 多次 run_path，会执行多次

