---
layout: post
title: "DINO"
date: 2025-12-26 +0800
categories: []
description: DINO
tags: CV
thumbnail: 
typora-root-url: ../
---

## 处理任意输入大小图片

```python
import numpy as np
import torch
import cv2
import os
import matplotlib.pyplot as plt
from PIL import Image
from sklearn.decomposition import PCA
from skimage.color import hsv2rgb
from transformers import AutoImageProcessor, AutoModel

# --- 1. 配置参数 ---
# 图像文件路径 (已设置为您的文件)
IMAGE_PATH = 'fruits.jpg' 
# DINOv2 模型 ID (Base 版本，公开且无需权限)
MODEL_ID = "facebook/dinov2-base" 
DEVICE = "cuda" if torch.cuda.is_available() else "cpu"
# DINOv2-base 默认 Patch size 为 14x14
PATCH_SIZE = 14 
# 设置一个最小的安全尺寸，防止原图太小
MIN_SIZE = 224 

def visualize_dinov2_features_variable_res(image_path, model_id, device, patch_size, min_size):
    """
    加载 DINOv2 模型，提取 Patch 特征，使用 PCA 降维并可视化。
    图像尺寸会调整到最接近原始尺寸且是 Patch Size 的整数倍。
    """
    if not os.path.exists(image_path):
        print(f"错误: 图像文件未找到于 '{image_path}'。请检查路径并重试。")
        return

    # --- 2. 初始化模型和处理器 ---
    print(f"正在加载 DINOv2 模型: {model_id} 到 {device}...")
    try:
        processor = AutoImageProcessor.from_pretrained(model_id)
        model = AutoModel.from_pretrained(model_id).to(device)
        model.eval() # 评估模式
    except Exception as e:
        print(f"模型加载失败。请检查模型 ID 或网络连接。\n错误信息: {e}")
        return

    # --- 3. 图像处理与特征提取 (重点修改部分) ---
    img = Image.open(image_path).convert("RGB")
    W_orig, H_orig = img.size
    print(f"原始图像尺寸 (W x H): {W_orig} x {H_orig}")

    # a. 计算目标输入尺寸 (必须是 PATCH_SIZE 的整数倍)
    # 取最接近原始尺寸且小于等于原始尺寸的 PATCH_SIZE 倍数
    H_target = (H_orig // patch_size) * patch_size
    W_target = (W_orig // patch_size) * patch_size
    
    # 确保尺寸不小于最小安全尺寸
    H_target = max(H_target, min_size)
    W_target = max(W_target, min_size)

    print(f"模型目标输入尺寸 (W x H): {W_target} x {H_target}")
    
    # b. 预处理
    # 显式传递 size 和 crop_size 参数，控制预处理器的缩放行为
    inputs = processor(
        images=img, 
        return_tensors="pt",
        size=(H_target, W_target), # 缩放或调整到目标尺寸
        crop_size=(H_target, W_target), # 确保不进行中心裁剪
        do_center_crop=False # 明确禁用中心裁剪
    ).to(device)

    # 实际输入模型张量的尺寸
    h_input = inputs['pixel_values'].shape[2]
    w_input = inputs['pixel_values'].shape[3]
    
    # 重新计算 Patch 网格尺寸 (H, W)
    h = h_input // patch_size
    w = w_input // patch_size
    
    # c. 提取特征
    with torch.no_grad():
        # **inputs 解包字典作为命名参数
        outputs = model(**inputs) 
        features = outputs.last_hidden_state.squeeze(0).cpu().numpy()

    # d. 移除 CLS Token
    if features.shape[0] == h * w + 1:
        features = features[1:] 
        print(f"已移除 CLS Token。剩余 Patch 特征形状: {features.shape}")
    else:
        print(f"Patch 特征形状: {features.shape}")

    # --- 4. PCA 降维 ---
    print("正在进行 PCA 降维...")
    pca = PCA(n_components=3).fit(features)
    pca_features = pca.transform(features)

    # 归一化到 [0, 1] 范围
    pca_min = pca_features.min(axis=0)
    pca_max = pca_features.max(axis=0)
    denominator = pca_max - pca_min
    denominator[denominator == 0] = 1e-8 
    pca_features_norm = (pca_features - pca_min) / denominator

    # --- 5. 可视化映射 ---

    # a. 重塑为网格形状 (H, W, 3)
    pca_grid = pca_features_norm.reshape(h, w, 3)

    # b. 映射到 HSV 颜色空间 
    hsv_image = np.zeros_like(pca_grid)
    hsv_image[..., 0] = pca_grid[..., 0]  # Hue (色调)
    hsv_image[..., 1] = 0.8              # Saturation (饱和度)
    hsv_image[..., 2] = pca_grid[..., 1]  # Value (亮度)

    # 转换为 RGB 颜色
    rgb_vis = hsv2rgb(hsv_image)
    
    # c. 缩放可视化结果到原始图像大小
    rgb_vis_upscaled = cv2.resize(
        rgb_vis, 
        (W_orig, H_orig), # 使用原图尺寸进行缩放
        interpolation=cv2.INTER_NEAREST # 最近邻插值保持 Patch 块状效果
    )

    # --- 6. 显示和保存结果 ---
    plt.figure(figsize=(12, 6))

    plt.subplot(1, 2, 1)
    plt.imshow(img)
    plt.title("原始图像 (Original Image: fruits.jpg)")
    plt.axis('off')

    plt.subplot(1, 2, 2)
    plt.imshow(rgb_vis_upscaled)
    plt.title(f"DINOv2 特征 PCA 可视化 ({W_target}x{H_target} 输入)")
    plt.axis('off')

    plt.tight_layout()
    output_filename = "dinov2_fruits_pca_visualization.png"
    plt.savefig(output_filename)
    print(f"可视化结果已保存为 {output_filename}")


if __name__ == "__main__":
    visualize_dinov2_features_variable_res(IMAGE_PATH, MODEL_ID, DEVICE, PATCH_SIZE, MIN_SIZE)
```
